<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>主な感染症の流行状況</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- D3.js v6 -->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <!-- 外部CSS -->
  <link rel="stylesheet" href="style23.css" />

  <!-- d3-simple-slider（あなたのコードに合わせて残す） -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.min.js"></script>
</head>

<body>
  <header>
    <h1>都道府県別にみた主な感染症の流行状況</h1>
    <p style="font-size:16px; line-height:1.5;">
      国立健康危機管理研究機構のデータをもとに、感染症の報告数（定点医療機関当たり）を都道府県別にグラフ化した。週単位で報告されている「5類感染症」が対象。グラフ下部にある黄色いバーの横幅を変えたり左右に動かしたりすると、表示する期間を指定できる。
    </p>
    <p style="font-size:14px; text-align:right;">朝日新聞デジタル企画報道部・小宮山亮磨 @ryomakom</p>
    <hr style="margin: 20px 0; border: none; border-top: 2px solid #ddd;">
  </header>

  <!-- 都道府県選択 -->
  <div id="controls">
    <label for="pref-dropdown">Select prefectures to show:</label>
    <div id="pref-dropdown" class="dropdown">
      <div id="dropdown-btn" class="dropdown-btn">(from here)</div>
      <div id="dropdown-content" class="dropdown-content"></div>
    </div>
  </div>

  <!-- 病気追加（デフォルト5 + 追加） -->
  <div id="category-controls" style="margin: 12px 0 6px;">
    <label for="disease-add">Select diseases to add:</label>
    <select id="disease-add">
      <option value="">（from here）</option>
    </select>
    <button id="disease-reset" type="button">Reset to 5 diseases</button>
  </div>

  <div id="chart-container"></div>

  <script>
    /***********************************************
     * 重なり防止用関数（軸ラベル）
     ***********************************************/
    function removeOverlappingTicksX(axisSelection) {
      let lastRight = -Infinity;
      axisSelection.selectAll("text").each(function () {
        const rect = this.getBoundingClientRect();
        if (rect.left < lastRight) {
          d3.select(this).style("display", "none");
        } else {
          d3.select(this).style("display", null);
          lastRight = rect.right;
        }
      });
    }
    function removeOverlappingTicksY(axisSelection) {
      let lastBottom = -Infinity;
      axisSelection.selectAll("text").each(function () {
        const rect = this.getBoundingClientRect();
        if (rect.top < lastBottom) {
          d3.select(this).style("display", "none");
        } else {
          d3.select(this).style("display", null);
          lastBottom = rect.bottom;
        }
      });
    }

    /***********************************************
     * 軸自動調整用（間隔・フォーマット）
     ***********************************************/
    function computeTickInterval(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 6) return d3.timeMonth.every(1);
      if (diffMonths < 12) return d3.timeMonth.every(2);
      if (diffMonths < 24) return d3.timeMonth.every(4);
      if (diffMonths < 60) return d3.timeYear.every(1);
      if (diffMonths < 96) return d3.timeYear.every(2);
      return d3.timeYear.every(3);
    }
    function computeTickFormat(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 12) return d3.timeFormat("%b");
      if (diffMonths < 24) return d3.timeFormat("%b %Y");
      return d3.timeFormat("%Y");
    }

    /***********************************************
     * Y軸 tick 値（あなたのロジック維持）
     ***********************************************/
    function computeCustomYAxisTicks(xMax) {
      if (xMax <= 0) return [];
      const n = Math.ceil(Math.log10(10 / xMax));
      const scale = Math.pow(10, n);
      const scaledMax = xMax * scale;
      const y = Math.round(scaledMax / 3) * 3;
      const y1 = y / 3;
      const y2 = y / 1.5;
      return [y1 / scale, y2 / scale];
    }

    /***********************************************
     * グローバル設定・変数
     ***********************************************/
    let allData = [];

    // 都道府県表示順（英語）
    const prefectureOrder = [
      "Nationwide","Hokkaido","Aomori","Iwate","Miyagi","Akita","Yamagata","Fukushima",
      "Ibaraki","Tochigi","Gunma","Saitama","Chiba","Tokyo","Kanagawa",
      "Niigata","Toyama","Ishikawa","Fukui","Yamanashi","Nagano","Gifu","Shizuoka","Aichi",
      "Mie","Shiga","Kyoto","Osaka","Hyogo","Nara","Wakayama",
      "Tottori","Shimane","Okayama","Hiroshima","Yamaguchi",
      "Tokushima","Kagawa","Ehime","Kochi",
      "Fukuoka","Saga","Nagasaki","Kumamoto","Oita","Miyazaki","Kagoshima","Okinawa"
    ];

    // disease_lookup と一致（全カテゴリ順）
    const allCategoryOrder = [
      // まず見たい：社会的インパクトが大きい & 変動も大きい
      "COVID-19","Flu","RSV","Gastroenteritis",
      // 小児で流行しやすく、ニュースにもなりやすい
      "Hand-foot-mouth disease","Chickenpox","Roseola","Fifth disease","Herpangina","Mumps",
      // 眼科系（集団感染・学校/職場で話題になりやすい）
      "Viral conjunctivitis","Hemorrhagic conjunctivitis",
      // 肺炎系（重症化の文脈で見せたい）
      "Mycoplasma pneumonia",
      "Chlamydia pneumonia",
      // 髄膜炎（頻度は高くないが重いので後半でまとまって提示）
      "Bacterial meningitis","Viral meningitis",
      // その他（一般の認知が相対的に低いので最後）
      "Adenovirus infection","Strep throat","Rotavirus"
    ];

    // デフォルト表示（指定の5つ）
    const defaultCategories = new Set([
      "Flu",
      "RSV",
      "COVID-19",
      "Hand-foot-mouth disease",
      "Gastroenteritis"
    ]);

    // 現在表示しているカテゴリ
    let selectedCategories = new Set(defaultCategories);

    // ブラシ状態保持
    const savedBrushExtents = {};

    // サイズ
    const focusMargin = { top: 10, right: 40, bottom: 33, left: 100 },
          focusWidth  = 900 - focusMargin.left - focusMargin.right,
          focusHeight = 320 - focusMargin.top - focusMargin.bottom;

    const contextMargin = { top: 10, right: 100, bottom: 30, left: 70 },
          contextWidth  = 900 - contextMargin.left - contextMargin.right,
          contextHeight = 60 - contextMargin.top - contextMargin.bottom;

    const parseDate = d3.timeParse("%Y-%m-%d");
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    let highlightedPref = null;

    // 「全国/東京都」英語でも日本語でも拾う（移行中のズレ対策）
    function isNationwide(p) { return p === "Nationwide" || p === "全国"; }
    function isTokyo(p)      { return p === "Tokyo" || p === "東京都"; }

    /***********************************************
     * CSV読み込み
     ***********************************************/
    function loadData(fileName) {
      return d3.csv(fileName, d => ({
        date: parseDate(d.date),
        value: +d.value,
        pref: d.pref,
        category: d.category,
        weekLabel: d["week_label_clean"]
      })).then(data => {
        const valid = data.filter(d => d.date);
        console.log(`Loaded ${fileName}: ${valid.length} records`);
        return valid;
      }).catch(err => {
        console.warn(`Failed to load ${fileName}:`, err);
        return [];
      });
    }

    // 初期データ読み込み（ここはあなたの現状のファイル名を維持）
    Promise.all([
      loadData("results/data-東京都.csv"),
      loadData("results/data-全国.csv")
    ]).then(results => {
      results.forEach(dataset => { allData = allData.concat(dataset); });
      console.log("Essential data loaded. Total records:", allData.length);

      initializeDropdown();
      initializeCategoryControls();

      setDefaultDropdownSelection();
      drawAllCharts(getSelectedDropdownPrefs());

      loadAdditionalData();
    }).catch(err => {
      console.error("Error loading essential CSV files:", err);
    });

    function loadAdditionalData() {
      loadData("results/data-その他.csv").then(dataOther => {
        allData = allData.concat(dataOther);
        console.log("Additional data loaded. Total records:", allData.length);
      }).catch(err => {
        console.error("Error loading additional CSV file:", err);
      });
    }

    /***********************************************
     * 都道府県ドロップダウン
     ***********************************************/
    function initializeDropdown() {
      const dropdownContent = d3.select("#dropdown-content");
      dropdownContent.html("");

      prefectureOrder.forEach(pref => {
        dropdownContent.append("div")
          .attr("class", "option")
          .attr("data-pref", pref)
          .text(pref)
          .on("click", function(event) {
            event.stopPropagation();
            d3.select(this).classed("selected", !d3.select(this).classed("selected"));
            updateDropdownBtn();
            drawAllCharts(getSelectedDropdownPrefs());
          });
      });

      d3.select("#dropdown-btn").on("click", function(event) {
        event.stopPropagation();
        d3.select("#pref-dropdown").classed("open", !d3.select("#pref-dropdown").classed("open"));
      });

      d3.select("body").on("click", function() {
        d3.select("#pref-dropdown").classed("open", false);
      });
    }

    function setDefaultDropdownSelection() {
      // 英語順リストを使っているので、デフォルトは Nationwide + Tokyo を狙う
      // （ただしデータ/移行中のズレ対策として全国/東京都も許容）
      d3.selectAll("#dropdown-content .option")
        .filter(function() {
          const p = d3.select(this).attr("data-pref");
          return (p === "Nationwide" || p === "全国" || p === "Tokyo" || p === "東京都");
        })
        .classed("selected", true);

      updateDropdownBtn();
    }

    function updateDropdownBtn() {
      const selected = getSelectedDropdownPrefs();
      const btn = d3.select("#dropdown-btn");
      if (selected.length === 0) {
        btn.text("ここから選ぶ");
      } else {
        btn.text(selected.join(", "));
      }
    }

    function getSelectedDropdownPrefs() {
      const options = d3.selectAll("#dropdown-content .option").nodes();
      return options
        .filter(opt => opt.classList.contains("selected"))
        .map(opt => opt.getAttribute("data-pref"));
    }

    /***********************************************
     * 病気追加コントロール
     ***********************************************/
    function initializeCategoryControls() {
      const select = document.getElementById("disease-add");
      const resetBtn = document.getElementById("disease-reset");

      function refreshOptions() {
        select.innerHTML = '<option value="">（from here）</option>';
        allCategoryOrder
          .filter(c => !selectedCategories.has(c))
          .forEach(c => {
            const opt = document.createElement("option");
            opt.value = c;
            opt.textContent = c;
            select.appendChild(opt);
          });
      }

      select.addEventListener("change", () => {
        const val = select.value;
        if (!val) return;
        selectedCategories.add(val);
        refreshOptions();
        select.value = "";
        drawAllCharts(getSelectedDropdownPrefs());
      });

      resetBtn.addEventListener("click", () => {
        selectedCategories = new Set(defaultCategories);
        refreshOptions();
        drawAllCharts(getSelectedDropdownPrefs());
      });

      refreshOptions();
    }

    /***********************************************
     * 全カテゴリーのグラフ描画（選択中カテゴリのみ）
     ***********************************************/
    function drawAllCharts(selectedPrefs) {
      d3.select("#chart-container").html("");
      highlightedPref = null;

      const filtered = allData.filter(d => selectedPrefs.includes(d.pref));

      let catGroups = d3.groups(filtered, d => d.category);

      // ★ここが変更：選択中カテゴリだけに絞る
      catGroups = catGroups.filter(([cat]) => selectedCategories.has(cat));

      // 並び順は allCategoryOrder に従う
      catGroups.sort((a, b) => {
        const indexA = allCategoryOrder.indexOf(a[0]);
        const indexB = allCategoryOrder.indexOf(b[0]);
        return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
      });

      catGroups.forEach(([cat, catData]) => {
        drawFocusContextChart(cat, catData);
      });
    }

    /***********************************************
     * 1カテゴリー分のフォーカス＆コンテキストチャート
     ***********************************************/
    function drawFocusContextChart(category, data) {
      data.sort((a, b) => a.date - b.date);
      const dataExtent = d3.extent(data, d => d.date);
      const yMax = d3.max(data, d => d.value) || 0;

      // 初期表示：最新から過去1年
      const defaultStart = new Date(
        (dataExtent[1] || new Date()).getFullYear() - 1,
        (dataExtent[1] || new Date()).getMonth(),
        (dataExtent[1] || new Date()).getDate()
      );
      const initialExtent = savedBrushExtents[category] || [defaultStart, dataExtent[1] || new Date()];

      const container = d3.select("#chart-container")
        .append("div")
        .attr("class", "chart");
      container.append("h2").text(category);

      const wrapper = container.append("div")
        .attr("class", "chart-wrapper");
      const leftCharts = wrapper.append("div")
        .attr("class", "left-charts");

      const svgFocus = leftCharts.append("svg")
        .attr("class", "svg-content chart-svg")
        .attr("viewBox", `0 0 ${focusWidth + focusMargin.left + focusMargin.right} ${focusHeight + focusMargin.top + focusMargin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", `translate(${focusMargin.left},${focusMargin.top})`);

      const xFocus = d3.scaleTime()
        .domain(initialExtent)
        .range([0, focusWidth]);

      const yFocus = d3.scaleLinear()
        .domain([0, yMax])
        .range([focusHeight, 0]);

      const tickInterval = computeTickInterval(xFocus.domain());
      const tickFormat = computeTickFormat(xFocus.domain());
      const xAxisFocus = d3.axisBottom(xFocus).ticks(tickInterval).tickFormat(tickFormat);

      const yTicks = computeCustomYAxisTicks(yFocus.domain()[1]);
      const yAxisFocus = d3.axisLeft(yFocus).tickValues(yTicks);

      const xAxisG = svgFocus.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${focusHeight})`)
        .call(xAxisFocus);
      removeOverlappingTicksX(xAxisG);

      svgFocus.append("g")
        .attr("class", "axis y-axis")
        .call(yAxisFocus);

      const lineFocus = d3.line()
        .defined(d => !isNaN(d.value))
        .x(d => xFocus(d.date))
        .y(d => yFocus(d.value));

      const prefGroups = d3.groups(data, d => d.pref);

      prefGroups.forEach(([pref, arr]) => {
        arr.sort((a, b) => a.date - b.date);

        const lineColor =
          isNationwide(pref) ? "blue" :
          isTokyo(pref)      ? "red"  :
          color(pref);

        svgFocus.append("path")
          .datum(arr)
          .attr("class", `line focus-line line-${pref}`)
          .attr("fill", "none")
          .attr("stroke", lineColor)
          .attr("stroke-width", 2)
          .attr("d", lineFocus)
          .on("mouseover", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", true);
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`<strong>${pref}</strong>`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", false);
            tooltip.transition().duration(500).style("opacity", 0);
          });

        svgFocus.selectAll(`circle.point-${pref}`)
          .data(arr)
          .enter()
          .append("circle")
          .attr("class", `point-${pref}`)
          .attr("r", 3)
          .attr("fill", lineColor)
          .attr("cx", d => xFocus(d.date))
          .attr("cy", d => yFocus(d.value))
          .on("mouseover", function(event, d) {
            d3.select(this).classed("highlight-circle", true);
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`<strong>${pref}</strong><br>Cases per site: ${d.value}<br>${d.weekLabel || ""}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function() {
            d3.select(this).classed("highlight-circle", false);
            tooltip.transition().duration(500).style("opacity", 0);
          });
      });

      // 凡例（複数都道府県）
      const legendContainer = wrapper.append("div")
        .attr("class", "chart-legend");

      const selectedPrefs = getSelectedDropdownPrefs();

      if (selectedPrefs.length > 1) {
        const legend = legendContainer.append("div").attr("class", "legend");
        const groupLookup = new Map(prefGroups);

        selectedPrefs.forEach(pref => {
          if (groupLookup.has(pref)) {
            const legendColor =
              isNationwide(pref) ? "blue" :
              isTokyo(pref)      ? "red"  :
              color(pref);

            legend.append("span")
              .attr("class", "legend-item")
              .attr("data-pref", pref)
              .style("color", legendColor)
              .text(pref)
              .on("click", () => {
                highlightedPref = (highlightedPref === pref) ? null : pref;
                updateVisibility(svgFocus, selectedPrefs);
              });
          }
        });
      }

      // コンテキスト（スライダー）
      const sliderWrapper = leftCharts.append("div")
        .attr("class", "slider-wrapper");
      sliderWrapper.append("h3").text("Time range");

      const xContext = d3.scaleTime()
        .domain(dataExtent)
        .range([0, contextWidth]);

      const xAxisContext = d3.axisBottom(xContext)
        .ticks(d3.timeYear.every(3))
        .tickFormat(d3.timeFormat("%Y"));   
      
      const svgContext = sliderWrapper.append("svg")
        .attr("class", "svg-content")
        .attr("viewBox", `0 0 ${contextWidth + contextMargin.left + contextMargin.right} ${contextHeight + contextMargin.top + contextMargin.bottom}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .append("g")
        .attr("transform", `translate(${contextMargin.left},${contextMargin.top})`);

      svgContext.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${contextHeight})`)
        .call(xAxisContext);

      const brush = d3.brushX()
        .extent([[0, 0], [contextWidth, contextHeight]])
        .on("brush end", brushed);

      const brushG = svgContext.append("g")
        .attr("class", "brush")
        .call(brush);

      // ハンドル（あなたの指定維持）
      const handleWidth  = 30;
      const handleHeight = contextHeight;

      brushG.selectAll(".handle")
        .attr("width",  handleWidth)
        .attr("height", handleHeight)
        .attr("rx", 0).attr("ry", 0)
        .attr("y", 0)
        .attr("x", (d,i) => i === 0 ? -handleWidth/2 : contextWidth - handleWidth/2);

      // 初期ブラシ位置
      if (savedBrushExtents[category]) {
        brushG.call(brush.move, [xContext(savedBrushExtents[category][0]), xContext(savedBrushExtents[category][1])]);
      } else {
        brushG.call(brush.move, [xContext(initialExtent[0]), xContext(initialExtent[1])]);
      }

      function brushed(event) {
        const sel = event.selection;
        if (!sel) return;

        const [x0, x1] = sel.map(xContext.invert);
        savedBrushExtents[category] = [x0, x1];

        xFocus.domain([x0, x1]);

        const newTickInterval = computeTickInterval(xFocus.domain());
        const newTickFormat = computeTickFormat(xFocus.domain());

        svgFocus.select(".x-axis")
          .call(d3.axisBottom(xFocus).ticks(newTickInterval).tickFormat(newTickFormat));
        removeOverlappingTicksX(svgFocus.select(".x-axis"));

        const visibleData = data.filter(d => d.date >= x0 && d.date <= x1);
        const newYMax = d3.max(visibleData, d => d.value) || 0;
        yFocus.domain([0, newYMax]);

        const newYTicks = computeCustomYAxisTicks(yFocus.domain()[1]);
        svgFocus.select(".y-axis")
          .call(d3.axisLeft(yFocus).tickValues(newYTicks));

        const prefGroupsLocal = d3.groups(visibleData, d => d.pref);

        prefGroupsLocal.forEach(([pref, arr]) => {
          arr.sort((a,b)=>a.date-b.date);

          svgFocus.selectAll(`.line-${pref}`)
            .datum(arr)
            .attr("d", lineFocus);

          const pointColor =
            isNationwide(pref) ? "blue" :
            isTokyo(pref)      ? "red"  :
            color(pref);

          svgFocus.selectAll(`circle.point-${pref}`)
            .data(arr, d => d.date)
            .join(
              enter => enter.append("circle")
                .attr("class", `point-${pref}`)
                .attr("r", 3)
                .attr("fill", pointColor)
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value))
                .on("mouseover", function(event, d) {
                  d3.select(this).classed("highlight-circle", true);
                  tooltip.transition().duration(200).style("opacity", 0.9);
                  tooltip.html(`<strong>${pref}</strong><br>定点当たり患者数: ${d.value}<br>${d.weekLabel || ""}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                  d3.select(this).classed("highlight-circle", false);
                  tooltip.transition().duration(500).style("opacity", 0);
                }),
              update => update
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value)),
              exit => exit.remove()
            );
        });

        updateVisibility(svgFocus, getSelectedDropdownPrefs());
      }

      function updateVisibility(svg, prefs) {
        if (!highlightedPref) {
          prefs.forEach(p => {
            svg.selectAll(`.line-${p}`).classed("inactive-line", false);
            svg.selectAll(`circle.point-${p}`).classed("inactive-circle", false);
          });
        } else {
          prefs.forEach(p => {
            const fade = (p !== highlightedPref);
            svg.selectAll(`.line-${p}`).classed("inactive-line", fade);
            svg.selectAll(`circle.point-${p}`).classed("inactive-circle", fade);
          });
        }
      }
    }
  </script>
</body>
</html>































