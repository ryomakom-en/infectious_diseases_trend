<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Infectious Disease Trends by Prefecture in Japan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- D3.js v6 -->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <!-- 外部CSS -->
  <link rel="stylesheet" href="style34.css" />

  <!-- d3-simple-slider（あなたのコードに合わせて残す） -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.min.js"></script>
</head>

<body>
  <header>
    <h1>Infectious Disease Trends by Prefecture in Japan</h1>
    <p style="font-size:16px; line-height:1.5;">
      Using data from Japan’s National Institute of Infectious Diseases, these interactive charts display infectious disease cases per sentinel site by prefecture. Drag the yellow bar at the bottom to change the time range.
    </p>
    <p style="font-size:14px; text-align:right;">Ryoma Komiyama</p>
    <hr style="margin: 20px 0; border: none; border-top: 2px solid #ddd;">
  </header>

<section class="controls-card">

  <div class="controls-title">
    Compare regions and diseases
  </div>

<!-- Prefectures -->
<div class="filter-group">
  <div class="filter-label">Prefectures</div>

  <div id="pref-selected" class="filter-tags">
    <!-- JSで動的に入る -->
  </div>

  <div class="filter-actions">
    <select id="pref-add">
      <option value="">+ Add prefecture</option>
    </select>

    <button id="pref-reset" type="button" class="link-button">
      Reset to default
    </button>
  </div>

  <!-- 既存ロジックの“状態保存”として残す（非表示でOK） -->
  <div id="pref-dropdown" class="dropdown" style="display:none;">
    <div id="dropdown-btn" class="dropdown-btn"></div>
    <div id="dropdown-content" class="dropdown-content"></div>
  </div>
</div>


  <!-- Diseases -->
  <div class="filter-group">
    <div class="filter-label">Diseases shown</div>

    <div id="disease-selected" class="filter-tags">
      <!-- JSで動的に入る -->
    </div>

    <div class="filter-actions">
      <select id="disease-add">
        <option value="">+ Add disease</option>
      </select>
      <button id="disease-reset" type="button" class="link-button">
        Reset to default
      </button>
    </div>
  </div>

</section>


  <div id="chart-container"></div>

  <script>
    /***********************************************
     * 重なり防止用関数（軸ラベル）
     ***********************************************/
    function removeOverlappingTicksX(axisSelection) {
      let lastRight = -Infinity;
      axisSelection.selectAll("text").each(function () {
        const rect = this.getBoundingClientRect();
        if (rect.left < lastRight) {
          d3.select(this).style("display", "none");
        } else {
          d3.select(this).style("display", null);
          lastRight = rect.right;
        }
      });
    }
    function removeOverlappingTicksY(axisSelection) {
      let lastBottom = -Infinity;
      axisSelection.selectAll("text").each(function () {
        const rect = this.getBoundingClientRect();
        if (rect.top < lastBottom) {
          d3.select(this).style("display", "none");
        } else {
          d3.select(this).style("display", null);
          lastBottom = rect.bottom;
        }
      });
    }

    /***********************************************
     * 軸自動調整用（間隔・フォーマット）
     ***********************************************/
    function computeTickInterval(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 6) return d3.timeMonth.every(1);
      if (diffMonths < 12) return d3.timeMonth.every(2);
      if (diffMonths < 24) return d3.timeMonth.every(4);
      if (diffMonths < 60) return d3.timeYear.every(1);
      if (diffMonths < 96) return d3.timeYear.every(2);
      return d3.timeYear.every(3);
    }
    function computeTickFormat(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 12) return d3.timeFormat("%b");
      if (diffMonths < 24) return d3.timeFormat("%b %Y");
      return d3.timeFormat("%Y");
    }

    /***********************************************
     * Y軸 tick 値（あなたのロジック維持）
     ***********************************************/
    function computeCustomYAxisTicks(xMax) {
      if (xMax <= 0) return [];
      const n = Math.ceil(Math.log10(10 / xMax));
      const scale = Math.pow(10, n);
      const scaledMax = xMax * scale;
      const y = Math.round(scaledMax / 3) * 3;
      const y1 = y / 3;
      const y2 = y / 1.5;
      return [y1 / scale, y2 / scale];
    }

    /***********************************************
     * グローバル設定・変数
     ***********************************************/
    let allData = [];

    // 都道府県表示順（英語）
    const prefectureOrder = [
      "Nationwide","Hokkaido","Aomori","Iwate","Miyagi","Akita","Yamagata","Fukushima",
      "Ibaraki","Tochigi","Gunma","Saitama","Chiba","Tokyo","Kanagawa",
      "Niigata","Toyama","Ishikawa","Fukui","Yamanashi","Nagano","Gifu","Shizuoka","Aichi",
      "Mie","Shiga","Kyoto","Osaka","Hyogo","Nara","Wakayama",
      "Tottori","Shimane","Okayama","Hiroshima","Yamaguchi",
      "Tokushima","Kagawa","Ehime","Kochi",
      "Fukuoka","Saga","Nagasaki","Kumamoto","Oita","Miyazaki","Kagoshima","Okinawa"
    ];

    // disease_lookup と一致（全カテゴリ順）
    const allCategoryOrder = [
      "COVID-19","Flu","RSV","Gastroenteritis",
      "Hand-foot-mouth disease","Chickenpox","Roseola","Fifth disease","Herpangina","Mumps",
      "Viral conjunctivitis","Hemorrhagic conjunctivitis",
      "Mycoplasma pneumonia",
      "Chlamydia pneumonia",
      "Bacterial meningitis","Viral meningitis",
      "Adenovirus infection","Strep throat","Rotavirus"
    ];

    // デフォルト表示（指定の5つ）
    const defaultCategories = new Set([
      "Flu","RSV","COVID-19","Hand-foot-mouth disease","Gastroenteritis"
    ]);

    // 現在表示しているカテゴリ
    let selectedCategories = new Set(defaultCategories);

    // ブラシ状態保持
    const savedBrushExtents = {};

    const parseDate = d3.timeParse("%Y-%m-%d");
    const color = d3.scaleOrdinal(d3.schemeCategory10);

    const tooltip = d3.select("body").append("div")
      .attr("class", "tooltip")
      .style("opacity", 0);

    let highlightedPref = null;

    // 「全国/東京都」英語でも日本語でも拾う（移行中のズレ対策）
    function isNationwide(p) { return p === "Nationwide" || p === "全国"; }
    function isTokyo(p)      { return p === "Tokyo" || p === "東京都"; }

    function prefColor(pref){
      return isNationwide(pref) ? "blue"
           : isTokyo(pref)      ? "red"
           : color(pref);
    }

    // 1列レイアウト判定（CSSのブレークポイントに合わせる）
    function isOneColumnLayout(){
      return window.matchMedia("(max-width: 899px)").matches;
    }

    // class名に使えるよう安全化（スペース等を潰す）
    function cssSafe(str){
      return String(str).replace(/[^a-zA-Z0-9_-]/g, "_");
    }

    /***********************************************
     * CSV読み込み
     ***********************************************/
    function loadData(fileName) {
      return d3.csv(fileName, d => ({
        date: parseDate(d.date),
        value: +d.value,
        pref: d.pref,
        category: d.category,
        weekLabel: d["week_label_clean"]
      })).then(data => {
        const valid = data.filter(d => d.date);
        console.log(`Loaded ${fileName}: ${valid.length} records`);
        return valid;
      }).catch(err => {
        console.warn(`Failed to load ${fileName}:`, err);
        return [];
      });
    }

    // 初期データ読み込み（あなたの現状のファイル名を維持）
    Promise.all([
      loadData("results/data-東京都.csv"),
      loadData("results/data-全国.csv")
    ]).then(results => {
      results.forEach(dataset => { allData = allData.concat(dataset); });
      console.log("Essential data loaded. Total records:", allData.length);

      initializeDropdown();
      initializeCategoryControls();
      initializePrefControls();

      setDefaultDropdownSelection();   // ★あなたの元コードのまま（ここが重要）
      drawAllCharts(getSelectedDropdownPrefs());

      loadAdditionalData();
      setupResizeRedraw();

    }).catch(err => {
      console.error("Error loading essential CSV files:", err);
    });

    function loadAdditionalData() {
      loadData("results/data-その他.csv").then(dataOther => {
        allData = allData.concat(dataOther);
        console.log("Additional data loaded. Total records:", allData.length);
        // 追加データ反映（選択状態は維持）
        drawAllCharts(getSelectedDropdownPrefs());
      }).catch(err => {
        console.error("Error loading additional CSV file:", err);
      });
    }

function setupResizeRedraw(){
  let t = null;

  // ★「幅」だけ監視（iOSのスクロール由来の高さ変化は無視する）
  let lastW = (window.visualViewport ? window.visualViewport.width : window.innerWidth);

  window.addEventListener("resize", () => {
    const w = (window.visualViewport ? window.visualViewport.width : window.innerWidth);

    // 幅がほぼ変わってないなら再描画しない（スクロールでのresize対策）
    if (Math.abs(w - lastW) < 2) return;

    lastW = w;

    clearTimeout(t);
    t = setTimeout(() => {
      drawAllCharts(getSelectedDropdownPrefs());
    }, 180);
  });

  // 端末回転は明示的に再描画
  window.addEventListener("orientationchange", () => {
    clearTimeout(t);
    t = setTimeout(() => {
      lastW = (window.visualViewport ? window.visualViewport.width : window.innerWidth);
      drawAllCharts(getSelectedDropdownPrefs());
    }, 250);
  });
}


    /***********************************************
     * 都道府県ドロップダウン
     ***********************************************/
    function initializeDropdown() {
      const dropdownContent = d3.select("#dropdown-content");
      dropdownContent.html("");

      prefectureOrder.forEach(pref => {
        dropdownContent.append("div")
          .attr("class", "option")
          .attr("data-pref", pref)
          .text(pref)
          .on("click", function(event) {
            event.stopPropagation();
            d3.select(this).classed("selected", !d3.select(this).classed("selected"));
            updateDropdownBtn();
            drawAllCharts(getSelectedDropdownPrefs());
            renderSelectedTags();
          });
      });

      d3.select("#dropdown-btn").on("click", function(event) {
        event.stopPropagation();
        d3.select("#pref-dropdown").classed("open", !d3.select("#pref-dropdown").classed("open"));
      });

      // ★追加：dropdown内部クリックは body に伝播させない（選べない事故防止）
      d3.select("#pref-dropdown").on("click", function(event){
        event.stopPropagation();
      });

      d3.select("body").on("click", function() {
        d3.select("#pref-dropdown").classed("open", false);
      });
    }

    function setDefaultDropdownSelection() {
      // ★ここはあなたの元コードの思想を維持して、data-pref を確実に見る
      d3.selectAll("#dropdown-content .option")
        .filter(function() {
          const p = d3.select(this).attr("data-pref");
          return (p === "Nationwide" || p === "全国" || p === "Tokyo" || p === "東京都");
        })
        .classed("selected", true);

      updateDropdownBtn();
      renderSelectedTags();
    }

    function updateDropdownBtn() {
      const selected = getSelectedDropdownPrefs();
      const btn = d3.select("#dropdown-btn");
      if (selected.length === 0) {
        btn.text("ここから選ぶ");
      } else {
        btn.text(selected.join(", "));
      }
    }

    function renderSelectedTags(){
  // Prefectures
  const prefBox = d3.select("#pref-selected");
  prefBox.html("");

  getSelectedDropdownPrefs().forEach(p => {
    prefBox.append("div")
      .attr("class", "filter-tag")
      .text(p + " ×")
      .on("click", () => {
        d3.select(`#dropdown-content .option[data-pref="${p}"]`)
          .classed("selected", false);
        updateDropdownBtn();
        drawAllCharts(getSelectedDropdownPrefs());
        renderSelectedTags();
      });
  });

  // Diseases
  const diseaseBox = d3.select("#disease-selected");
  diseaseBox.html("");

  [...selectedCategories].forEach(d => {
    diseaseBox.append("div")
      .attr("class", "filter-tag")
      .text(d + " ×")
      .on("click", () => {
        selectedCategories.delete(d);
        drawAllCharts(getSelectedDropdownPrefs());
        renderSelectedTags();
      });
  });
}

    
    function getSelectedDropdownPrefs() {
      const options = d3.selectAll("#dropdown-content .option").nodes();
      return options
        .filter(opt => opt.classList.contains("selected"))
        .map(opt => opt.getAttribute("data-pref"));
    }

    /***********************************************
     * 病気追加コントロール
     ***********************************************/
    function initializeCategoryControls() {
      const select = document.getElementById("disease-add");
      const resetBtn = document.getElementById("disease-reset");

      function refreshOptions() {
        select.innerHTML = '<option value="">（from here）</option>';
        allCategoryOrder
          .filter(c => !selectedCategories.has(c))
          .forEach(c => {
            const opt = document.createElement("option");
            opt.value = c;
            opt.textContent = c;
            select.appendChild(opt);
          });
      }

      select.addEventListener("change", () => {
        const val = select.value;
        if (!val) return;
        selectedCategories.add(val);
        refreshOptions();
        select.value = "";
        drawAllCharts(getSelectedDropdownPrefs());
        renderSelectedTags();
      });

      resetBtn.addEventListener("click", () => {
        selectedCategories = new Set(defaultCategories);
        refreshOptions();
        drawAllCharts(getSelectedDropdownPrefs());
        renderSelectedTags();
      });

      refreshOptions();
    }
    
    function initializePrefControls(){
  const select = document.getElementById("pref-add");
  const resetBtn = document.getElementById("pref-reset");

  function refreshOptions(){
    select.innerHTML = '<option value="">+ Add prefecture</option>';

    const selected = new Set(getSelectedDropdownPrefs());
    prefectureOrder
      .filter(p => !selected.has(p))
      .forEach(p => {
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = p;
        select.appendChild(opt);
      });
  }

  select.addEventListener("change", () => {
    const val = select.value;
    if (!val) return;

    // 既存の状態（.option.selected）をONにする
    d3.selectAll("#dropdown-content .option")
      .filter(function(){
        return d3.select(this).attr("data-pref") === val;
      })
      .classed("selected", true);

    updateDropdownBtn();                 // 既存関数（中の挙動は残してOK）
    drawAllCharts(getSelectedDropdownPrefs());
    renderSelectedTags();
    refreshOptions();
    select.value = "";
  });

  resetBtn.addEventListener("click", () => {
    // いったん全解除
    d3.selectAll("#dropdown-content .option").classed("selected", false);

    // デフォルトだけON（あなたの既存ロジックと同じ）
    d3.selectAll("#dropdown-content .option")
      .filter(function(){
        const p = d3.select(this).attr("data-pref");
        return (p === "Nationwide" || p === "Tokyo" || p === "全国" || p === "東京都");
      })
      .classed("selected", true);

    updateDropdownBtn();
    drawAllCharts(getSelectedDropdownPrefs());
    renderSelectedTags();
    refreshOptions();
  });

  refreshOptions();
}


    /***********************************************
     * 全カテゴリーのグラフ描画（選択中カテゴリのみ）
     ***********************************************/
    function drawAllCharts(selectedPrefs) {
      d3.select("#chart-container").html("");
      // highlightedPref は保持（あなたの元の挙動に合わせる）

      const filtered = allData.filter(d => selectedPrefs.includes(d.pref));
      let catGroups = d3.groups(filtered, d => d.category);

      // 選択中カテゴリだけ
      catGroups = catGroups.filter(([cat]) => selectedCategories.has(cat));

      // 並び順は allCategoryOrder に従う
      catGroups.sort((a, b) => {
        const indexA = allCategoryOrder.indexOf(a[0]);
        const indexB = allCategoryOrder.indexOf(b[0]);
        return (indexA === -1 ? Infinity : indexA) - (indexB === -1 ? Infinity : indexB);
      });

      catGroups.forEach(([cat, catData]) => {
        drawFocusContextChart(cat, catData);
      });
    }

    /***********************************************
     * 1カテゴリー分のフォーカス＆コンテキストチャート
     * ★変更は最小：
     *   - viewBox依存をやめ、width/height実寸でSVG生成
     *   - leftWをカード内実幅から算出してはみ出し防止
     ***********************************************/
    function drawFocusContextChart(category, data) {
      // =============================
// Layout constants（必須）
// =============================

// --- Focus chart ---
const focusMargin = { top: 10, right: 20, bottom: 26, left: 36 };
const FOCUS_OUTER_H = 220;
const focusHeight =
  FOCUS_OUTER_H - focusMargin.top - focusMargin.bottom;

// --- Context (slider) ---
const contextMargin = { top: 6, right: 26, bottom: 30, left: 44 }; // ★下・左右を増やす
const contextHeight = 26;                                          // ★軸を少し下げる
const CONTEXT_OUTER_H =
  contextHeight + contextMargin.top + contextMargin.bottom;        // ★外枠は「中身＋margin」で自動計算





      data.sort((a, b) => a.date - b.date);
      const dataExtent = d3.extent(data, d => d.date);
      const yMaxAll = d3.max(data, d => d.value) || 0;

      // 初期表示：最新から過去1年
      const endDate = dataExtent[1] || new Date();
      const defaultStart = new Date(endDate.getFullYear() - 1, endDate.getMonth(), endDate.getDate());
      const initialExtent = savedBrushExtents[category] || [defaultStart, endDate];

      const container = d3.select("#chart-container")
        .append("div")
        .attr("class", "chart");

      container.append("h2").text(category);

      const wrapper = container.append("div").attr("class", "chart-wrapper");
      const leftCharts = wrapper.append("div").attr("class", "left-charts");

      // 凡例（複数都道府県）
      const legendContainer = wrapper.append("div").attr("class", "chart-legend");

      const selectedPrefs = getSelectedDropdownPrefs();
      const prefGroupsAll = d3.groups(data, d => d.pref);
      const groupLookup = new Map(prefGroupsAll);

      if (selectedPrefs.length > 1) {
        const legend = legendContainer.append("div").attr("class", "legend");

        selectedPrefs.forEach(pref => {
          if (!groupLookup.has(pref)) return;

          legend.append("span")
            .attr("class", "legend-item")
            .attr("data-pref", pref)
            .style("color", prefColor(pref))
            .text(pref)
            .on("click", () => {
              highlightedPref = (highlightedPref === pref) ? null : pref;
              updateVisibility(svgFocus, selectedPrefs);
            });
        });
      }

      /* --------------------------
         ★はみ出し防止：leftWをカード内実幅から算出
         - スマホ（1列）では凡例は下に回るので legendW=0 とみなす
         -------------------------- */
      const GAP = 10;          // .chart-wrapper の gap と合わせる
      const paddingLR = 20;    // .chart の padding 10px*2（CSSと一致）
      const cardInnerW = container.node().clientWidth - paddingLR;
      
      const oneCol = isOneColumnLayout();
      const legendW = oneCol ? 0 : (legendContainer.node().getBoundingClientRect().width || 0);
      
      const available = Math.floor(cardInnerW - (oneCol ? 0 : (legendW + GAP)));
      const leftW = Math.max(260, available);   // ★520強制をやめる（枠内に収める）
      leftCharts.style("width", leftW + "px");

// ★ここで「実際の leftCharts の幅」を測る（flexで縮んだ分を反映）
const leftChartsW = leftCharts.node().clientWidth;

// SVG外枠（実測に合わせる）
const totalFocusW = leftChartsW;
const totalFocusH = FOCUS_OUTER_H;

// 描画領域
const focusWidth = Math.max(1, totalFocusW - focusMargin.left - focusMargin.right);

const svgFocusRoot = leftCharts.append("svg")
  .attr("class", "svg-content chart-svg")
  .attr("width", totalFocusW)
  .attr("height", totalFocusH);

      const svgFocus = svgFocusRoot.append("g")
        .attr("transform", `translate(${focusMargin.left},${focusMargin.top})`);

      const xFocus = d3.scaleTime()
        .domain(initialExtent)
        .range([0, focusWidth]);

      const yFocus = d3.scaleLinear()
        .domain([0, yMaxAll])
        .range([focusHeight, 0]);

      const tickInterval = computeTickInterval(xFocus.domain());
      const tickFormat = computeTickFormat(xFocus.domain());
      const xAxisFocus = d3.axisBottom(xFocus).ticks(tickInterval).tickFormat(tickFormat);

      const yTicks = computeCustomYAxisTicks(yFocus.domain()[1]);
      const yAxisFocus = d3.axisLeft(yFocus).tickValues(yTicks);

      const xAxisG = svgFocus.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${focusHeight})`)
        .call(xAxisFocus);
      removeOverlappingTicksX(xAxisG);

      svgFocus.append("g")
        .attr("class", "axis y-axis")
        .call(yAxisFocus);

      const lineFocus = d3.line()
        .defined(d => !isNaN(d.value))
        .x(d => xFocus(d.date))
        .y(d => yFocus(d.value));

      const prefGroups = d3.groups(data, d => d.pref);

      prefGroups.forEach(([pref, arr]) => {
        arr.sort((a, b) => a.date - b.date);

        const lineColor = prefColor(pref);
        const safe = cssSafe(pref);

        svgFocus.append("path")
          .datum(arr)
          .attr("class", `line focus-line line-${safe}`)
          .attr("fill", "none")
          .attr("stroke", lineColor)
          .attr("stroke-width", 2)
          .attr("d", lineFocus)
          .on("mouseover", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", true);
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`<strong>${pref}</strong>`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", false);
            tooltip.transition().duration(500).style("opacity", 0);
          });

        svgFocus.selectAll(`circle.point-${safe}`)
          .data(arr)
          .enter()
          .append("circle")
          .attr("class", `point-${safe}`)
          .attr("r", 3)
          .attr("fill", lineColor)
          .attr("cx", d => xFocus(d.date))
          .attr("cy", d => yFocus(d.value))
          .on("mouseover", function(event, d) {
            d3.select(this).classed("highlight-circle", true);
            tooltip.transition().duration(200).style("opacity", 0.9);
            tooltip.html(`<strong>${pref}</strong><br>Cases per site: ${d.value}<br>${d.weekLabel || ""}`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 28) + "px");
          })
          .on("mouseout", function() {
            d3.select(this).classed("highlight-circle", false);
            tooltip.transition().duration(500).style("opacity", 0);
          });
      });

/* --------------------------
   Context（スライダー）
   -------------------------- */
const sliderWrapper = leftCharts.append("div")
  .attr("class", "slider-wrapper");

sliderWrapper.append("h3").text("Time range");

// 外枠サイズ（leftCharts 実測ベース）
const totalCtxW = leftChartsW;
const totalCtxH = CONTEXT_OUTER_H;

// 先に width を確定（重要）
const contextWidth =
  Math.max(1, totalCtxW - contextMargin.left - contextMargin.right);

// scale / axis
const xContext = d3.scaleTime()
  .domain(dataExtent)
  .range([0, contextWidth]);

const xAxisContext = d3.axisBottom(xContext)
  .ticks(d3.timeYear.every(3))
  .tickFormat(d3.timeFormat("%Y"));

// SVG
const svgContext = sliderWrapper.append("svg")
  .attr("class", "svg-content")
  .attr("viewBox", `0 0 ${totalCtxW} ${totalCtxH}`)
  .attr("preserveAspectRatio", "xMidYMid meet")
  .append("g")
  .attr("transform", `translate(${contextMargin.left},${contextMargin.top})`);

// Axis
const ctxAxisG = svgContext.append("g")
  .attr("class", "axis x-axis")
  .attr("transform", `translate(0,${contextHeight})`)
  .call(xAxisContext);

removeOverlappingTicksX(ctxAxisG);

// Brush
const brush = d3.brushX()
  .extent([[0, 0], [contextWidth, contextHeight]])
  .on("brush end", brushed);

const brushG = svgContext.append("g")
  .attr("class", "brush")
  .call(brush);

// Handles
const handleWidth = 30;

brushG.selectAll(".handle")
  .attr("width", handleWidth)
  .attr("height", contextHeight)
  .attr("y", 0)
  .attr("x", (d, i) =>
    i === 0 ? -handleWidth / 2 : contextWidth - handleWidth / 2
  );

// Initial position
if (savedBrushExtents[category]) {
  brushG.call(brush.move, [
    xContext(savedBrushExtents[category][0]),
    xContext(savedBrushExtents[category][1])
  ]);
} else {
  brushG.call(brush.move, [
    xContext(initialExtent[0]),
    xContext(initialExtent[1])
  ]);
}


      // 初期表示でもハイライト反映
      updateVisibility(svgFocus, selectedPrefs);

      function brushed(event) {
        const sel = event.selection;
        if (!sel) return;

        const [x0, x1] = sel.map(xContext.invert);
        savedBrushExtents[category] = [x0, x1];

        xFocus.domain([x0, x1]);

        const newTickInterval = computeTickInterval(xFocus.domain());
        const newTickFormat = computeTickFormat(xFocus.domain());

        svgFocus.select(".x-axis")
          .call(d3.axisBottom(xFocus).ticks(newTickInterval).tickFormat(newTickFormat));
        removeOverlappingTicksX(svgFocus.select(".x-axis"));

        const visibleData = data.filter(d => d.date >= x0 && d.date <= x1);
        const newYMax = d3.max(visibleData, d => d.value) || 0;
        yFocus.domain([0, newYMax]);

        const newYTicks = computeCustomYAxisTicks(yFocus.domain()[1]);
        svgFocus.select(".y-axis")
          .call(d3.axisLeft(yFocus).tickValues(newYTicks));

        const prefGroupsLocal = d3.groups(visibleData, d => d.pref);

        prefGroupsLocal.forEach(([pref, arr]) => {
          arr.sort((a,b)=>a.date-b.date);

          const safe = cssSafe(pref);

          svgFocus.selectAll(`.line-${safe}`)
            .datum(arr)
            .attr("d", lineFocus);

          const pointColor = prefColor(pref);

          svgFocus.selectAll(`circle.point-${safe}`)
            .data(arr, d => d.date)
            .join(
              enter => enter.append("circle")
                .attr("class", `point-${safe}`)
                .attr("r", 3)
                .attr("fill", pointColor)
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value))
                .on("mouseover", function(event, d) {
                  d3.select(this).classed("highlight-circle", true);
                  tooltip.transition().duration(200).style("opacity", 0.9);
                  tooltip.html(`<strong>${pref}</strong><br>定点当たり患者数: ${d.value}<br>${d.weekLabel || ""}`)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                  d3.select(this).classed("highlight-circle", false);
                  tooltip.transition().duration(500).style("opacity", 0);
                }),
              update => update
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value)),
              exit => exit.remove()
            );
        });

        updateVisibility(svgFocus, getSelectedDropdownPrefs());
      }

      function updateVisibility(svg, prefs) {
        if (!highlightedPref) {
          prefs.forEach(p => {
            const safe = cssSafe(p);
            svg.selectAll(`.line-${safe}`).classed("inactive-line", false);
            svg.selectAll(`circle.point-${safe}`).classed("inactive-circle", false);
          });
        } else {
          prefs.forEach(p => {
            const safe = cssSafe(p);
            const fade = (p !== highlightedPref);
            svg.selectAll(`.line-${safe}`).classed("inactive-line", fade);
            svg.selectAll(`circle.point-${safe}`).classed("inactive-circle", fade);
          });
        }
      }
    }
  </script>
</body>
</html>




