<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>都道府県別にみた主な感染症の流行状況</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- D3.js v6 -->
  <script src="https://d3js.org/d3.v6.min.js"></script>

  <!-- 外部CSS（あなたが全面書き直した style23.css を置く） -->
  <link rel="stylesheet" href="style24.css" />

  <!-- d3-simple-slider（依存があっても問題ないので残す） -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-simple-slider/1.6.3/d3-simple-slider.min.js"></script>
</head>

<body>
  <header>
    <h1>都道府県別にみた主な感染症の流行状況</h1>
    <p>
      国立健康危機管理研究機構のデータをもとに、感染症の報告数（定点医療機関当たり）を都道府県別にグラフ化した。
      週単位で報告されている「5類感染症」が対象。グラフ下部にある黄色いバーの横幅を変えたり左右に動かしたりすると、
      表示する期間を指定できる。
    </p>
    <p style="font-size:14px; text-align:right;">朝日新聞デジタル企画報道部・小宮山亮磨 @ryomakom</p>
    <hr style="margin: 16px 0; border: none; border-top: 2px solid #ddd;">
  </header>

  <!-- 都道府県選択 -->
  <div id="controls">
    <label>表示する都道府県：</label>
    <div id="pref-dropdown" class="dropdown">
      <div id="dropdown-btn" class="dropdown-btn">（ここから選ぶ）</div>
      <div id="dropdown-content" class="dropdown-content"></div>
    </div>
  </div>

  <!-- 病気追加 -->
  <div id="category-controls">
    <label>表示する感染症：</label>
    <select id="disease-add">
      <option value="">（追加する）</option>
    </select>
    <button id="disease-reset" type="button">初期5疾患に戻す</button>
  </div>

  <!-- チャート -->
  <div id="chart-container"></div>

  <!-- Tooltip（CSSで .tooltip 定義済み） -->
  <div class="tooltip"></div>

  <script>
    /***********************************************
     * 重なり防止（X軸ラベル）
     ***********************************************/
    function removeOverlappingTicksX(axisSelection) {
      let lastRight = -Infinity;
      axisSelection.selectAll("text").each(function () {
        const rect = this.getBoundingClientRect();
        if (rect.left < lastRight) {
          d3.select(this).style("display", "none");
        } else {
          d3.select(this).style("display", null);
          lastRight = rect.right;
        }
      });
    }

    /***********************************************
     * 軸自動調整（X軸 tick 間隔・フォーマット）
     ***********************************************/
    function computeTickInterval(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 6) return d3.timeMonth.every(1);
      if (diffMonths < 12) return d3.timeMonth.every(2);
      if (diffMonths < 24) return d3.timeMonth.every(4);
      if (diffMonths < 60) return d3.timeYear.every(1);
      if (diffMonths < 96) return d3.timeYear.every(2);
      return d3.timeYear.every(3);
    }

    function computeTickFormat(domain) {
      const start = domain[0], end = domain[1];
      const diffMonths = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
      if (diffMonths < 12) return d3.timeFormat("%b");
      if (diffMonths < 24) return d3.timeFormat("%b %Y");
      return d3.timeFormat("%Y");
    }

    /***********************************************
     * Y軸 tick 値（あなたのロジック）
     ***********************************************/
    function computeCustomYAxisTicks(xMax) {
      if (xMax <= 0) return [];
      const n = Math.ceil(Math.log10(10 / xMax));
      const scale = Math.pow(10, n);
      const scaledMax = xMax * scale;
      const y = Math.round(scaledMax / 3) * 3;
      const y1 = y / 3;
      const y2 = y / 1.5;
      return [y1 / scale, y2 / scale];
    }

    /***********************************************
     * ユーティリティ
     ***********************************************/
    const parseDate = d3.timeParse("%Y-%m-%d");
    const color = d3.scaleOrdinal(d3.schemeCategory10);
    const tooltip = d3.select(".tooltip");

    function showTooltip(html, event){
      tooltip.style("opacity", 1)
        .html(html)
        .style("left", (event.pageX + 10) + "px")
        .style("top",  (event.pageY - 28) + "px");
    }
    function hideTooltip(){
      tooltip.style("opacity", 0);
    }

    // 「全国/東京都」英語でも日本語でも拾う（移行中のズレ対策）
    function isNationwide(p) { return p === "Nationwide" || p === "全国"; }
    function isTokyo(p)      { return p === "Tokyo" || p === "東京都"; }

    function prefColor(pref){
      if (isNationwide(pref)) return "blue";
      if (isTokyo(pref)) return "red";
      return color(pref);
    }

    function isOneColumnLayout(){
      // CSSが 899px 以下で 1列・凡例下に回す想定
      return window.matchMedia("(max-width: 899px)").matches;
    }

    /***********************************************
     * グローバル状態
     ***********************************************/
    let allData = [];

    const prefectureOrder = [
      "Nationwide","Hokkaido","Aomori","Iwate","Miyagi","Akita","Yamagata","Fukushima",
      "Ibaraki","Tochigi","Gunma","Saitama","Chiba","Tokyo","Kanagawa",
      "Niigata","Toyama","Ishikawa","Fukui","Yamanashi","Nagano","Gifu","Shizuoka","Aichi",
      "Mie","Shiga","Kyoto","Osaka","Hyogo","Nara","Wakayama",
      "Tottori","Shimane","Okayama","Hiroshima","Yamaguchi",
      "Tokushima","Kagawa","Ehime","Kochi",
      "Fukuoka","Saga","Nagasaki","Kumamoto","Oita","Miyazaki","Kagoshima","Okinawa"
    ];

    const allCategoryOrder = [
      "COVID-19","Flu","RSV","Gastroenteritis",
      "Hand-foot-mouth disease","Chickenpox","Roseola","Fifth disease","Herpangina","Mumps",
      "Viral conjunctivitis","Hemorrhagic conjunctivitis",
      "Mycoplasma pneumonia","Chlamydia pneumonia",
      "Bacterial meningitis","Viral meningitis",
      "Adenovirus infection","Strep throat","Rotavirus"
    ];

    const defaultCategories = new Set([
      "Flu","RSV","COVID-19","Hand-foot-mouth disease","Gastroenteritis"
    ]);
    let selectedCategories = new Set(defaultCategories);

    // ブラシ状態（カテゴリごとに Date のまま保持）
    const savedBrushExtents = {};

    // 凡例クリックでハイライトする都道府県（グローバル：全チャートに効く）
    let highlightedPref = null;

    /***********************************************
     * CSV読み込み
     ***********************************************/
    function loadData(fileName) {
      return d3.csv(fileName, d => ({
        date: parseDate(d.date),
        value: +d.value,
        pref: d.pref,
        category: d.category,
        weekLabel: d["week_label_clean"]
      })).then(data => data.filter(d => d.date));
    }

    Promise.all([
      loadData("results/data-全国.csv"),
      loadData("results/data-東京都.csv"),
      loadData("results/data-その他.csv")
    ]).then(results => {
      results.forEach(ds => allData.push(...ds));

      initializeDropdown();
      initializeCategoryControls();
      setDefaultDropdownSelection();

      drawAllCharts(getSelectedDropdownPrefs());
      setupResizeRedraw();

    }).catch(err => {
      console.error("Error loading CSV files:", err);
    });

    /***********************************************
     * 都道府県ドロップダウン
     ***********************************************/
    function initializeDropdown() {
      const dropdownContent = d3.select("#dropdown-content");
      dropdownContent.html("");

      prefectureOrder.forEach(pref => {
        dropdownContent.append("div")
          .attr("class", "option")
          .attr("data-pref", pref)
          .text(pref)
          .on("click", function(event) {
            event.stopPropagation();
            d3.select(this).classed("selected", !d3.select(this).classed("selected"));
            updateDropdownBtn();
            drawAllCharts(getSelectedDropdownPrefs());
          });
      });

      d3.select("#dropdown-btn").on("click", function(event) {
        event.stopPropagation();
        d3.select("#pref-dropdown").classed("open", !d3.select("#pref-dropdown").classed("open"));
      });

      d3.select("body").on("click", function() {
        d3.select("#pref-dropdown").classed("open", false);
      });
    }

    function setDefaultDropdownSelection() {
      // デフォルト：全国＋東京（英語名を主に想定）
      d3.selectAll("#dropdown-content .option")
        .filter(function() {
          const p = d3.select(this).attr("data-pref");
          return (p === "Nationwide" || p === "全国" || p === "Tokyo" || p === "東京都");
        })
        .classed("selected", true);

      updateDropdownBtn();
    }

    function updateDropdownBtn() {
      const selected = getSelectedDropdownPrefs();
      const btn = d3.select("#dropdown-btn");
      btn.text(selected.length ? selected.join(", ") : "（ここから選ぶ）");
    }

    function getSelectedDropdownPrefs() {
      return d3.selectAll("#dropdown-content .option.selected")
        .nodes()
        .map(n => n.getAttribute("data-pref"));
    }

    /***********************************************
     * 病気追加コントロール
     ***********************************************/
    function initializeCategoryControls() {
      const select = document.getElementById("disease-add");
      const resetBtn = document.getElementById("disease-reset");

      function refreshOptions() {
        select.innerHTML = '<option value="">（追加する）</option>';
        allCategoryOrder
          .filter(c => !selectedCategories.has(c))
          .forEach(c => {
            const opt = document.createElement("option");
            opt.value = c;
            opt.textContent = c;
            select.appendChild(opt);
          });
      }

      select.addEventListener("change", () => {
        const val = select.value;
        if (!val) return;
        selectedCategories.add(val);
        refreshOptions();
        select.value = "";
        drawAllCharts(getSelectedDropdownPrefs());
      });

      resetBtn.addEventListener("click", () => {
        selectedCategories = new Set(defaultCategories);
        refreshOptions();
        drawAllCharts(getSelectedDropdownPrefs());
      });

      refreshOptions();
    }

    /***********************************************
     * リサイズ時に再描画（デバウンス）
     ***********************************************/
    function setupResizeRedraw(){
      let t = null;
      window.addEventListener("resize", () => {
        clearTimeout(t);
        t = setTimeout(() => {
          drawAllCharts(getSelectedDropdownPrefs());
        }, 180);
      });
    }

    /***********************************************
     * 全カテゴリーのグラフ描画（選択中のみ）
     ***********************************************/
    function drawAllCharts(selectedPrefs) {
      const root = d3.select("#chart-container");
      root.html("");
      // ハイライト状態は保持（highlightedPref はグローバル）

      const filtered = allData.filter(d => selectedPrefs.includes(d.pref));
      let catGroups = d3.groups(filtered, d => d.category);

      catGroups = catGroups
        .filter(([cat]) => selectedCategories.has(cat))
        .sort((a, b) => {
          const ia = allCategoryOrder.indexOf(a[0]);
          const ib = allCategoryOrder.indexOf(b[0]);
          return (ia === -1 ? 9999 : ia) - (ib === -1 ? 9999 : ib);
        });

      catGroups.forEach(([cat, catData]) => {
        drawFocusContextChart(cat, catData, selectedPrefs);
      });
    }

    /***********************************************
     * 1カテゴリー分のフォーカス＆コンテキストチャート
     * - SVGは viewBox でスケールしない（pxで固定）
     * - はみ出し防止：カード内実幅から leftW を計算
     * - 1列レイアウト時は凡例を下に回す（JSでも legendW を引かない）
     ***********************************************/
    function drawFocusContextChart(category, data, selectedPrefs) {
      data.sort((a, b) => a.date - b.date);
      const dataExtent = d3.extent(data, d => d.date);
      const endDate = dataExtent[1] || new Date();

      // 初期表示：最新から過去1年
      const defaultStart = new Date(endDate.getFullYear() - 1, endDate.getMonth(), endDate.getDate());
      const initialExtent = savedBrushExtents[category] || [defaultStart, endDate];

      // --- カード枠
      const container = d3.select("#chart-container")
        .append("div")
        .attr("class", "chart");

      container.append("h2").text(category);

      const wrapper = container.append("div").attr("class", "chart-wrapper");
      const leftCharts = wrapper.append("div").attr("class", "left-charts");
      const legendContainer = wrapper.append("div").attr("class", "chart-legend");

      // --- 凡例（クリックで線＋点ハイライト）
      const prefGroupsAll = d3.groups(data, d => d.pref);
      const groupLookup = new Map(prefGroupsAll);

      if (selectedPrefs.length > 1) {
        const legend = legendContainer.append("div").attr("class", "legend");

        selectedPrefs.forEach(pref => {
          if (!groupLookup.has(pref)) return;

          legend.append("span")
            .attr("class", "legend-item")
            .attr("data-pref", pref)
            .style("color", prefColor(pref))
            .text(pref)
            .on("click", () => {
              highlightedPref = (highlightedPref === pref) ? null : pref;
              updateVisibility();
            });
        });
      }

      // --- leftCharts 実幅を計算（はみ出し防止）
      const GAP = 10; // CSSの .chart-wrapper gap と合わせる
      const paddingLR = 20; // .chart padding 10px * 2 を想定
      const cardInnerW = container.node().clientWidth - paddingLR;

      const oneCol = isOneColumnLayout();
      const legendW = oneCol ? 0 : (legendContainer.node().getBoundingClientRect().width || 0);

      const leftW = Math.max(520, Math.floor(cardInnerW - legendW - (oneCol ? 0 : GAP)));
      leftCharts.style("width", leftW + "px");

      // --- Focus / Context サイズ
      const focusMargin  = { top: 10, right: 40, bottom: 33, left: 100 };
      const focusHeight  = 320 - focusMargin.top - focusMargin.bottom;
      const focusWidth   = Math.max(260, leftW - focusMargin.left - focusMargin.right);

      const contextMargin = { top: 10, right: 100, bottom: 30, left: 70 };
      const contextHeight = 60 - contextMargin.top - contextMargin.bottom;
      const contextWidth  = Math.max(260, leftW - contextMargin.left - contextMargin.right);

      // --- Focus SVG（viewBoxなし、実寸）
      const totalFocusW = focusWidth + focusMargin.left + focusMargin.right;
      const totalFocusH = focusHeight + focusMargin.top + focusMargin.bottom;

      const svgFocusRoot = leftCharts.append("svg")
        .attr("class", "svg-content chart-svg")
        .attr("width", totalFocusW)
        .attr("height", totalFocusH);

      const svgFocus = svgFocusRoot.append("g")
        .attr("transform", `translate(${focusMargin.left},${focusMargin.top})`);

      // スケール
      const xFocus = d3.scaleTime()
        .domain(initialExtent)
        .range([0, focusWidth]);

      const yMaxAll = d3.max(data, d => d.value) || 0;

      const yFocus = d3.scaleLinear()
        .domain([0, yMaxAll])
        .range([focusHeight, 0]);

      // X軸（自動）
      const tickInterval = computeTickInterval(xFocus.domain());
      const tickFormat = computeTickFormat(xFocus.domain());
      const xAxisFocus = d3.axisBottom(xFocus).ticks(tickInterval).tickFormat(tickFormat);

      const xAxisG = svgFocus.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${focusHeight})`)
        .call(xAxisFocus);

      removeOverlappingTicksX(xAxisG);

      // Y軸（あなたの tick ロジック）
      const yTicks0 = computeCustomYAxisTicks(yFocus.domain()[1]);
      const yAxisFocus = d3.axisLeft(yFocus).tickValues(yTicks0);

      svgFocus.append("g")
        .attr("class", "axis y-axis")
        .call(yAxisFocus);

      // ライン
      const lineFocus = d3.line()
        .defined(d => !isNaN(d.value))
        .x(d => xFocus(d.date))
        .y(d => yFocus(d.value));

      // 都道府県ごとの描画（line + points）
      const prefGroups = d3.groups(data, d => d.pref);

      prefGroups.forEach(([pref, arr]) => {
        arr.sort((a, b) => a.date - b.date);
        const c = prefColor(pref);

        svgFocus.append("path")
          .datum(arr)
          .attr("class", `line focus-line line-${cssSafe(pref)}`)
          .attr("fill", "none")
          .attr("stroke", c)
          .attr("stroke-width", 2)
          .attr("d", lineFocus)
          .on("mouseover", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", true);
            showTooltip(`<strong>${pref}</strong>`, event);
          })
          .on("mouseout", (event) => {
            d3.select(event.currentTarget).classed("highlight-line", false);
            hideTooltip();
          });

        svgFocus.selectAll(`circle.point-${cssSafe(pref)}`)
          .data(arr)
          .enter()
          .append("circle")
          .attr("class", `point point-${cssSafe(pref)}`)
          .attr("r", 3)
          .attr("fill", c)
          .attr("cx", d => xFocus(d.date))
          .attr("cy", d => yFocus(d.value))
          .on("mouseover", function(event, d) {
            d3.select(this).classed("highlight-circle", true);
            showTooltip(
              `<strong>${pref}</strong><br>定点当たり患者数: ${d.value}<br>${d.weekLabel || ""}`,
              event
            );
          })
          .on("mouseout", function() {
            d3.select(this).classed("highlight-circle", false);
            hideTooltip();
          });
      });

      // --- Context（スライダー）エリア
      const sliderWrapper = leftCharts.append("div").attr("class", "slider-wrapper");
      sliderWrapper.append("h3").text("Time range");

      const totalCtxW = contextWidth + contextMargin.left + contextMargin.right;
      const totalCtxH = contextHeight + contextMargin.top + contextMargin.bottom;

      const svgContextRoot = sliderWrapper.append("svg")
        .attr("class", "svg-content")
        .attr("width", totalCtxW)
        .attr("height", totalCtxH);

      const svgContext = svgContextRoot.append("g")
        .attr("transform", `translate(${contextMargin.left},${contextMargin.top})`);

      const xContext = d3.scaleTime()
        .domain(dataExtent)
        .range([0, contextWidth]);

      const xAxisContext = d3.axisBottom(xContext)
        .ticks(d3.timeYear.every(3))
        .tickFormat(d3.timeFormat("%Y"));

      svgContext.append("g")
        .attr("class", "axis x-axis")
        .attr("transform", `translate(0,${contextHeight})`)
        .call(xAxisContext);

      const brush = d3.brushX()
        .extent([[0, 0], [contextWidth, contextHeight]])
        .on("brush end", brushed);

      const brushG = svgContext.append("g")
        .attr("class", "brush")
        .call(brush);

      // ハンドル（あなたの指定維持）
      const handleWidth  = 30;
      const handleHeight = contextHeight;

      brushG.selectAll(".handle")
        .attr("width",  handleWidth)
        .attr("height", handleHeight)
        .attr("rx", 0).attr("ry", 0)
        .attr("y", 0)
        .attr("x", (d,i) => i === 0 ? -handleWidth/2 : contextWidth - handleWidth/2);

      // 初期ブラシ位置
      const init = savedBrushExtents[category] || initialExtent;
      brushG.call(brush.move, [xContext(init[0]), xContext(init[1])]);

      // 初期状態の可視性適用（ハイライト保持）
      updateVisibility();

      /***********************************************
       * brushed: focus を更新（軸・線・点・Ytick）
       ***********************************************/
      function brushed(event) {
        const sel = event.selection;
        if (!sel) return;

        const [x0, x1] = sel.map(xContext.invert);
        savedBrushExtents[category] = [x0, x1];

        xFocus.domain([x0, x1]);

        // X軸更新
        const newTickInterval = computeTickInterval(xFocus.domain());
        const newTickFormat = computeTickFormat(xFocus.domain());

        svgFocus.select(".x-axis")
          .call(d3.axisBottom(xFocus).ticks(newTickInterval).tickFormat(newTickFormat));
        removeOverlappingTicksX(svgFocus.select(".x-axis"));

        // 表示範囲内データだけで yMax を更新
        const visibleData = data.filter(d => d.date >= x0 && d.date <= x1);
        const newYMax = d3.max(visibleData, d => d.value) || 0;
        yFocus.domain([0, newYMax]);

        // Y軸 tick（あなたのロジック）
        const newYTicks = computeCustomYAxisTicks(yFocus.domain()[1]);
        svgFocus.select(".y-axis")
          .call(d3.axisLeft(yFocus).tickValues(newYTicks));

        // 線・点更新（prefごと）
        const prefGroupsLocal = d3.groups(visibleData, d => d.pref);

        prefGroupsLocal.forEach(([pref, arr]) => {
          arr.sort((a,b)=>a.date-b.date);

          svgFocus.selectAll(`.line-${cssSafe(pref)}`)
            .datum(arr)
            .attr("d", lineFocus);

          const c = prefColor(pref);

          svgFocus.selectAll(`circle.point-${cssSafe(pref)}`)
            .data(arr, d => +d.date)
            .join(
              enter => enter.append("circle")
                .attr("class", `point point-${cssSafe(pref)}`)
                .attr("r", 3)
                .attr("fill", c)
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value))
                .on("mouseover", function(event, d) {
                  d3.select(this).classed("highlight-circle", true);
                  showTooltip(
                    `<strong>${pref}</strong><br>定点当たり患者数: ${d.value}<br>${d.weekLabel || ""}`,
                    event
                  );
                })
                .on("mouseout", function() {
                  d3.select(this).classed("highlight-circle", false);
                  hideTooltip();
                }),
              update => update
                .attr("cx", d => xFocus(d.date))
                .attr("cy", d => yFocus(d.value)),
              exit => exit.remove()
            );
        });

        // ハイライト状態を反映
        updateVisibility();
      }

      /***********************************************
       * 凡例クリック反映：線＋点を同時にフェード
       ***********************************************/
      function updateVisibility() {
        const prefs = selectedPrefs;

        if (!highlightedPref) {
          prefs.forEach(p => {
            svgFocus.selectAll(`.line-${cssSafe(p)}`).classed("inactive-line", false);
            svgFocus.selectAll(`circle.point-${cssSafe(p)}`).classed("inactive-circle", false);
          });
          return;
        }

        prefs.forEach(p => {
          const fade = (p !== highlightedPref);
          svgFocus.selectAll(`.line-${cssSafe(p)}`).classed("inactive-line", fade);
          svgFocus.selectAll(`circle.point-${cssSafe(p)}`).classed("inactive-circle", fade);
        });
      }

      // CSSクラス用に安全化（スペース等を潰す）
      function cssSafe(str){
        return String(str).replace(/[^a-zA-Z0-9_-]/g, "_");
      }
    }
  </script>
</body>
</html>
